#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# leme_cookie_autostart.py
#
# 使用浏览器 Cookie 调 Pterodactyl Client API：
# - GET  /api/client/servers/{id}/resources  -> 获取 current_state
# - POST /api/client/servers/{id}/power      -> {"signal":"start"} 启动
#
# 环境变量：
# - PANEL_BASE   必填，例如 https://panel.lemehost.com 或 https://lemehost.com（以实际面板域名为准）
# - SERVER_IDS   必填，短 UUID，支持多个，用逗号分隔，例如 abc123,def456
# - COOKIE       必填，完整 Cookie 字符串：pterodactyl_session=...; XSRF-TOKEN=...; [可能还有 cf_clearance=...]
# - CSRF_TOKEN   可选；不填则自动从 Cookie 的 XSRF-TOKEN 中提取
# - TIMEOUT      可选，默认 20（秒）
# - USER_AGENT   可选，自定义 UA

import os
import sys
import json
import time
import traceback
import requests
from http.cookies import SimpleCookie
from urllib.parse import unquote as urlunquote

DEFAULT_UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118 Safari/537.36 GH-Actions/lemehost-cookie-autostart"

def log(*args):
    print(time.strftime("[%Y-%m-%d %H:%M:%S]"), *args, flush=True)

def parse_cookie_str(cookie_str: str) -> dict:
    c = SimpleCookie()
    c.load(cookie_str)
    return {k: morsel.value for k, morsel in c.items()}

def build_session(cookie_str: str, csrf_token: str | None, ua: str | None):
    s = requests.Session()
    s.trust_env = False
    s.headers.update({
        "Accept": "application/json",
        "Content-Type": "application/json",
        "X-Requested-With": "XMLHttpRequest",
        "User-Agent": ua or DEFAULT_UA,
    })
    # 注入 Cookie
    if cookie_str:
        for k, v in parse_cookie_str(cookie_str).items():
            s.cookies.set(k, v)

    # CSRF：优先用传入的 CSRF_TOKEN，缺失则尝试从 XSRF-TOKEN Cookie 里取
    token = csrf_token
    if not token:
        xsrf = s.cookies.get("XSRF-TOKEN") or s.cookies.get("XSRF_TOKEN")
        if xsrf:
            # Pterodactyl 常把 XSRF-TOKEN 进行 URL 编码
            token = urlunquote(xsrf)
    if token:
        # 常见两种写法，双写更稳
        s.headers["X-CSRF-Token"] = token
        s.headers["X-CSRF-TOKEN"] = token
    return s

def get_state(session: requests.Session, base: str, sid: str, timeout: int) -> tuple[bool, str | None, str]:
    url = f"{base}/api/client/servers/{sid}/resources"
    headers = {
        "Origin": base,
        "Referer": f"{base}/server/{sid}",
    }
    r = session.get(url, headers=headers, timeout=timeout)
    if not r.ok:
        return False, None, f"HTTP {r.status_code} {r.text[:200]}"
    try:
        data = r.json()
        state = data.get("attributes", {}).get("current_state")
        return True, state, ""
    except Exception as e:
        return False, None, f"JSON parse error: {e} {r.text[:200]}"

def start_server(session: requests.Session, base: str, sid: str, timeout: int) -> tuple[bool, str]:
    url = f"{base}/api/client/servers/{sid}/power"
    headers = {
        "Origin": base,
        "Referer": f"{base}/server/{sid}",
    }
    body = {"signal": "start"}
    r = session.post(url, headers=headers, data=json.dumps(body), timeout=timeout)
    # Pterodactyl 正常返回 204，无响应体
    if r.status_code == 204:
        return True, "204 No Content"
    ok = 200 <= r.status_code < 300
    text = r.text[:300]
    return ok, f"{r.status_code} {text}"

def main():
    base = (os.getenv("PANEL_BASE") or "").rstrip("/")
    ids_raw = os.getenv("SERVER_IDS") or ""
    cookie_str = os.getenv("COOKIE") or ""
    csrf_token = os.getenv("CSRF_TOKEN") or None
    timeout = int(os.getenv("TIMEOUT") or "20")
    ua = os.getenv("USER_AGENT") or None

    if not base or not ids_raw or not cookie_str:
        log("ERROR: 缺少必要环境变量 PANEL_BASE / SERVER_IDS / COOKIE")
        sys.exit(2)

    ids = [x.strip() for x in ids_raw.split(",") if x.strip()]
    session = build_session(cookie_str, csrf_token, ua)

    results = []
    exit_code = 0

    for sid in ids:
        try:
            ok, state, err = get_state(session, base, sid, timeout)
            if not ok:
                log(f"[{sid}] 获取状态失败 -> {err}")
                results.append({"id": sid, "ok": False, "error": err})
                # 如果是 401/419/403，多半是 Cookie 或 CSRF 问题
                exit_code = 1
                continue

            log(f"[{sid}] current_state = {state}")
            if state in ("running", "starting"):
                results.append({"id": sid, "ok": True, "message": f"already {state}"})
                continue

            # 尝试启动，带一次轻量重试（处理偶发 429/5xx）
            for attempt in range(1, 3):
                ok2, info = start_server(session, base, sid, timeout)
                log(f"[{sid}] start attempt {attempt} -> {info}")
                if ok2:
                    results.append({"id": sid, "ok": True, "message": "start sent"})
                    break
                if attempt == 1:
                    time.sleep(2)
            else:
                results.append({"id": sid, "ok": False, "error": "start failed"})
                exit_code = 1

        except Exception as e:
            log(f"[{sid}] 异常: {e}")
            traceback.print_exc()
            results.append({"id": sid, "ok": False, "error": str(e)})
            exit_code = 1

    print(json.dumps({"ok": exit_code == 0, "results": results}, ensure_ascii=False))
    sys.exit(exit_code)

if __name__ == "__main__":
    main()
